generator client {
    provider = "prisma-client-js"
    output   = "../generated/prisma"
}

datasource db {
    provider = "postgresql"
}

model conversations {
    id           String     @id @default(cuid())
    createdAt    DateTime   @default(now()) @map("created_at")
    updatedAt    DateTime   @default(now()) @map("updated_at")
    contractorId String     @map("contractor_id")
    homeownerId  String     @map("homeowner_id")
    contractor   users      @relation("conversations_contractor_idTousers", fields: [contractorId], references: [id])
    homeowner    users      @relation("conversations_homeowner_idTousers", fields: [homeownerId], references: [id])
    messages     messages[]

    @@unique([contractorId, homeownerId], map: "conversations_contractor_id_homeowner_id_key")
    @@index([contractorId], map: "conversations_contractor_id_idx")
    @@index([createdAt], map: "conversations_created_at_idx")
    @@index([homeownerId], map: "conversations_homeowner_id_idx")
}



model messages {
    id             String        @id @default(cuid())
    text           String
    createdAt      DateTime      @default(now()) @map("created_at")
    senderId       String        @map("sender_id")
    conversationId String        @map("conversation_id")
    conversation   conversations @relation(fields: [conversationId], references: [id])
    sender         users         @relation(fields: [senderId], references: [id])

    @@index([conversationId], map: "messages_conversation_id_idx")
    @@index([createdAt], map: "messages_created_at_idx")
}



model users {
    id                      String          @id @default(cuid())
    createdAt               DateTime        @default(now()) @map("created_at")
    updatedAt               DateTime        @default(now()) @map("updated_at")
    name                    String
    username                String          @unique
    password                String
    role                    UserRole
    contractorConversations conversations[] @relation("conversations_contractor_idTousers")
    homeownerConversations  conversations[] @relation("conversations_homeowner_idTousers")
    messages                messages[]
    recipes                 recipes[]
    recipeGroups            recipe_groups[]
    files                   files[]
    ingredients             ingredients[]
    aiThreads               ai_threads[]

    @@index([username], map: "users_username_idx")
}

// AI Chat Threads - stores conversation threads with AI assistant
model ai_threads {
    id        String        @id @default(cuid())
    title     String        @default("New Chat")
    userId    String        @map("user_id")
    createdAt DateTime      @default(now()) @map("created_at")
    updatedAt DateTime      @updatedAt @map("updated_at")
    deletedAt DateTime?     @map("deleted_at")
    user      users         @relation(fields: [userId], references: [id])
    messages  ai_messages[]

    @@index([userId], map: "ai_threads_user_id_idx")
    @@index([createdAt], map: "ai_threads_created_at_idx")
    @@index([deletedAt], map: "ai_threads_deleted_at_idx")
}

// AI Chat Messages - stores individual messages in AI threads
model ai_messages {
    id         String          @id @default(cuid())
    threadId   String          @map("thread_id")
    role       AIMessageRole
    content    String          @db.Text
    toolName   String?         @map("tool_name") // For tool messages: name of the tool
    toolStatus String?         @map("tool_status") // For tool messages: running, success, error
    createdAt  DateTime        @default(now()) @map("created_at")
    thread     ai_threads      @relation(fields: [threadId], references: [id], onDelete: Cascade)

    @@index([threadId], map: "ai_messages_thread_id_idx")
    @@index([createdAt], map: "ai_messages_created_at_idx")
}

model recipes {
    id       String   @id @default(cuid())
    name     String
    servings Int
    userId   String   @map("user_id")
    tags     String[] @default([])

    // Ratings
    overallRating Int? @map("overall_rating") // Avaliação geral (1-5)

    // Time in minutes
    prepTimeMinutes Int? @map("prep_time_minutes") // Tempo médio para fazer

    // Instructions in markdown format
    instructions String? @db.Text

    createdAt         DateTime               @default(now()) @map("created_at")
    updatedAt         DateTime               @default(now()) @map("updated_at")
    deletedAt         DateTime?              @map("deleted_at")
    user              users                  @relation(fields: [userId], references: [id])
    recipeIngredients recipe_ingredients[]
    recipeGroups      recipe_group_recipes[]
    files             recipe_files[]

    @@index([userId], map: "recipes_user_id_idx")
    @@index([createdAt], map: "recipes_created_at_idx")
    @@index([deletedAt], map: "recipes_deleted_at_idx")
}

// Tabela de ingredientes base (reutilizável entre receitas)
// userId = null means system ingredient (visible to all users)
// userId = user.id means user's own ingredient
// When querying, use DISTINCT ON (name) with user's ingredients taking precedence
model ingredients {
    id          String   @id @default(cuid())
    name        String // Nome do ingrediente (ex: "Tomate", "Arroz")
    description String? // Descrição opcional
    categories  String[] @default([]) // Array de categorias (validated by GraphQL enum)
    defaultUnit String?  @map("default_unit") // Unidade padrão para uso em receitas (ex: "g", "ml", "unidade")

    // Preço: "R$ 5,00 por litro" ou "R$ 0,10 por ml"
    averagePrice  Decimal? @map("average_price") // Valor do preço (ex: 5.00)
    priceUnit     String?  @map("price_unit") // Unidade do preço (ex: "litro", "kg", "unidade")
    priceCurrency String?  @default("BRL") @map("price_currency") // Moeda (BRL, USD, etc)

    // Vector embedding for semantic search (1536 dimensions for OpenAI text-embedding-3-small)
    embedding Unsupported("vector(1536)")?

    // NULL = system ingredient (visible to all users), otherwise user's ingredient
    userId            String?              @map("user_id")
    createdAt         DateTime             @default(now()) @map("created_at")
    updatedAt         DateTime             @default(now()) @map("updated_at")
    deletedAt         DateTime?            @map("deleted_at")
    user              users?               @relation(fields: [userId], references: [id])
    recipeIngredients recipe_ingredients[] // Receitas que usam este ingrediente
    files             ingredient_files[] // Fotos do ingrediente

    // Unique name per user (null userId = system level)
    @@unique([name, userId], name: "ingredients_name_user_unique")
    @@index([userId], map: "ingredients_user_id_idx")
    @@index([name], map: "ingredients_name_idx")
    @@index([categories], map: "ingredients_categories_idx")
}

// Relacionamento entre receita e ingrediente (com quantidade específica)
model recipe_ingredients {
    id           String      @id @default(cuid())
    recipeId     String      @map("recipe_id")
    ingredientId String      @map("ingredient_id")
    quantity     Decimal // Quantidade usada nesta receita
    unit         String // Unidade (pode ser diferente da padrão)
    notes        String? // Notas opcionais (ex: "picado", "ralado")
    optional     Boolean     @default(false) // Se o ingrediente é opcional (ex: ketchup para batata frita)
    price        Decimal? // Preço específico para este item (opcional, sobrescreve o preço do ingrediente)
    createdAt    DateTime    @default(now()) @map("created_at")
    updatedAt    DateTime    @default(now()) @map("updated_at")
    recipe       recipes     @relation(fields: [recipeId], references: [id], onDelete: Cascade)
    ingredient   ingredients @relation(fields: [ingredientId], references: [id], onDelete: Cascade)

    @@index([recipeId], map: "recipe_ingredients_recipe_id_idx")
    @@index([ingredientId], map: "recipe_ingredients_ingredient_id_idx")
}

model recipe_groups {
    id          String                 @id @default(cuid())
    name        String
    description String?
    userId      String                 @map("user_id")
    createdAt   DateTime               @default(now()) @map("created_at")
    updatedAt   DateTime               @default(now()) @map("updated_at")
    deletedAt   DateTime?              @map("deleted_at")
    user        users                  @relation(fields: [userId], references: [id])
    recipes     recipe_group_recipes[]
    files       recipe_group_files[]

    @@index([userId], map: "recipe_groups_user_id_idx")
    @@index([createdAt], map: "recipe_groups_created_at_idx")
    @@index([deletedAt], map: "recipe_groups_deleted_at_idx")
}

model recipe_group_recipes {
    id        String        @id @default(cuid())
    recipeId  String        @map("recipe_id")
    groupId   String        @map("group_id")
    createdAt DateTime      @default(now()) @map("created_at")
    recipe    recipes       @relation(fields: [recipeId], references: [id], onDelete: Cascade)
    group     recipe_groups @relation(fields: [groupId], references: [id], onDelete: Cascade)

    @@unique([recipeId, groupId], map: "recipe_group_recipes_recipe_id_group_id_unique")
    @@index([recipeId], map: "recipe_group_recipes_recipe_id_idx")
    @@index([groupId], map: "recipe_group_recipes_group_id_idx")
}

model files {
    id               String               @id @default(cuid())
    key              String               @unique
    bucket           String // S3 bucket name
    region           String // AWS region
    filename         String
    mimeType         String               @map("mime_type")
    size             Int
    createdAt        DateTime             @default(now()) @map("created_at")
    updatedAt        DateTime             @default(now()) @map("updated_at")
    deletedAt        DateTime?            @map("deleted_at")
    uploaderId       String               @map("uploaded_by")
    uploader         users                @relation(fields: [uploaderId], references: [id])
    recipeFiles      recipe_files[]
    recipeGroupFiles recipe_group_files[]
    ingredientFiles  ingredient_files[]

    @@index([uploaderId], map: "files_uploaded_by_idx")
    @@index([createdAt], map: "files_created_at_idx")
    @@index([deletedAt], map: "files_deleted_at_idx")
}

model recipe_files {
    id        String   @id @default(cuid())
    recipeId  String   @map("recipe_id")
    fileId    String   @map("file_id")
    createdAt DateTime @default(now()) @map("created_at")
    recipe    recipes  @relation(fields: [recipeId], references: [id], onDelete: Cascade)
    file      files    @relation(fields: [fileId], references: [id], onDelete: Cascade)

    @@unique([recipeId, fileId], map: "recipe_files_recipe_id_file_id_unique")
    @@index([recipeId], map: "recipe_files_recipe_id_idx")
    @@index([fileId], map: "recipe_files_file_id_idx")
}

model recipe_group_files {
    id        String        @id @default(cuid())
    groupId   String        @map("group_id")
    fileId    String        @map("file_id")
    createdAt DateTime      @default(now()) @map("created_at")
    group     recipe_groups @relation(fields: [groupId], references: [id], onDelete: Cascade)
    file      files         @relation(fields: [fileId], references: [id], onDelete: Cascade)

    @@unique([groupId, fileId], map: "recipe_group_files_group_id_file_id_unique")
    @@index([groupId], map: "recipe_group_files_group_id_idx")
    @@index([fileId], map: "recipe_group_files_file_id_idx")
}

// Tabela para fotos de ingredientes
model ingredient_files {
    id           String      @id @default(cuid())
    ingredientId String      @map("ingredient_id")
    fileId       String      @map("file_id")
    createdAt    DateTime    @default(now()) @map("created_at")
    ingredient   ingredients @relation(fields: [ingredientId], references: [id], onDelete: Cascade)
    file         files       @relation(fields: [fileId], references: [id])

    @@unique([ingredientId, fileId], map: "ingredient_files_ingredient_id_file_id_key")
    @@index([ingredientId], map: "ingredient_files_ingredient_id_idx")
    @@index([fileId], map: "ingredient_files_file_id_idx")
}

enum UserRole {
    contractor
    homeowner
}

enum AIMessageRole {
    user
    assistant
    tool
}
